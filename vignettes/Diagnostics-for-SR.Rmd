---
title: "再生産関係モデル診断スクリプト"
author: "Shota Nishijima"
date: "`r Sys.Date()`"
output:
  html_document:
  highlight: kate
toc: yes
toc_float: yes
vignette: >
  %\VignetteIndexEntry{Diagnostics-for-SR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

再生産関係の選択・診断を行うためのチェックリストです。ここで、将来予測・管理基準値計算チュートリアル (../docs/future.html) の例を使って説明します。

  <!-- ## 0. 使用データ・解析コード等 -->
  <!-- 加入量・親魚量データ：平成29年度年度マサバ太平洋系群資源評価票における加入量・親魚量データ   -->
  <!-- 期間：1970~2016年    -->
  <!-- 使用プログラム:future.vpa1.11   -->
  <!-- 環境要因データ：なし   -->

# 再生産関係のレジームがないと考えられる場合。

## 1. 再生産関係型の比較

Hockey-Stick型/Beverton-Holt型/Ricker型の再生産関係を比較します。

```{r setup}
library(frasyr)
data(res_vpa)
SRdata <- get.SRdata(res_vpa)
resHS <- fit.SR(SRdata,SR="HS",method="L2",AR=0)
resBH <- fit.SR(SRdata,SR="BH",method="L2",AR=0)
resRI <- fit.SR(SRdata,SR="RI",method="L2",AR=0)
plot(SRdata$R ~ SRdata$SSB, cex=2, type = "b",xlab="SSB",ylab="R",
     main="HS vs. BH vs. RI",ylim=c(0,max(SRdata$R)*1.3),xlim=c(0,max(SRdata$SSB)*1.1))
points(rev(SRdata$SSB)[1],rev(SRdata$R)[1],col=1,type="p",lwd=3,pch=16,cex=2)
points(resHS$pred$SSB,resHS$pred$R,col=2,type="l",lwd=3)
points(resBH$pred$SSB,resBH$pred$R,col=3,type="l",lwd=3,lty=2)
points(resRI$pred$SSB,resRI$pred$R,col=4,type="l",lwd=3,lty=3)
legend("topleft",
       legend=c(sprintf("HS %5.2f",resHS$AICc),sprintf("BH %5.2f",resBH$AICc),sprintf("RI %5.2f",resRI$AICc)),
       lty=1:3,col=2:4,lwd=2,title="AICc",ncol=3)
resSR <- resHS #HSを選択
```
**選択した再生産関係：Hockey-Stick**

  理由（特にBHやRIの場合は詳しく）：
BHとRIでは再生産関係がほぼ直線になるため、HSを選択した。AICcもHSがやや小さい。

## 2. 最小絶対値法や残差の自己相関の検討

サンプル数が少ない場合や残差が正規分布に従っていない場合（4節参照）、外れ値に対して頑健な推定方法である最小絶対値法（中央値推定）が有効なオプションとして考えられます。
また、加入の残差が環境影響などにより時間的なトレンドをもつ場合には（4節参照）、残差の自己相関を考慮する方法が考えられます。ただし、外側で自己相関を推定する場合、AICの値は自己相関を考慮しない場合と等しくなるので、推定されるパラメータrhoや次節以降のチェック手続きをへて適切な再生産関係を選択してください。
ここでは、これらの手法により再生産関係がどの程度変わるのかをチェックします。（実際の手続きとしては上記１節の他のSR関数でもチェックしてください。）

```{r,message=FALSE,warning=FALSE}
resL2 = fit.SR(SRdata, SR = "HS", method = "L2", out.AR = FALSE, AR = 0)
resL2outer = fit.SR(SRdata, SR = "HS", method = "L2", out.AR = TRUE, AR = 1)
resL2inner = fit.SR(SRdata, SR = "HS", method = "L2", out.AR = FALSE, AR = 1)
resL1 = fit.SR(SRdata, SR = "HS", method = "L1", out.AR = FALSE, AR = 0)
resL1outer = fit.SR(SRdata, SR = "HS", method = "L1", out.AR = TRUE, AR = 1)
resL1inner = fit.SR(SRdata, SR = "HS", method = "L1", out.AR = FALSE, AR = 1)
plot(SRdata$R ~ SRdata$SSB, cex=2, type = "b",xlab="SSB",ylab="R",
     main="Effects of autocorrelation and L1",ylim=c(0,max(SRdata$R)*1.3),xlim=c(0,max(SRdata$SSB)*1.1))
points(rev(SRdata$SSB)[1],rev(SRdata$R)[1],col=1,type="p",lwd=3,pch=16,cex=2)
points(resL2$pred$SSB,resL2$pred$R,col=2,type="l",lwd=3)
points(resL2inner$pred$SSB,resL2inner$pred$R,col=3,type="l",lwd=3,lty=2)
points(resL2outer$pred$SSB,resL2outer$pred$R,col=4,type="l",lwd=3,lty=3)
points(resL1$pred$SSB,resL1$pred$R,col=5,type="l",lwd=3)
points(resL1inner$pred$SSB,resL1inner$pred$R,col=6,type="l",lwd=3,lty=2)
points(resL1outer$pred$SSB,resL1outer$pred$R,col=7,type="l",lwd=3,lty=3)
legend("topleft",
       legend=c(sprintf("L2&AR0 %5.2f",resL2$AICc),sprintf("L1&AR0 %5.2f",resL1$AICc),sprintf("L2&AR1inner %5.2f",resL2inner$AICc),sprintf("L1&AR1inner %5.2f",resL1inner$AICc),sprintf("L2&AR1outer %5.2f",resL2outer$AICc),sprintf("L1&AR1outer %5.2f",resL1outer$AICc)),
       lty=c(1,1,2,2,3,3),col=c(2,5,3,6,4,7),lwd=2,title="AICc",ncol=3)
```
**選択した再生産関係：L2&AR0**

  理由：
AICcの値からL1推定はL2より高くなった。自己相関を内側で推定した場合もAICcは高くなった。外側推定した場合、rhoの値が小さかった(rho=0.04)ので自己相関のない場合を採用した。

## 3. 推定値の収束の有無や最適解に達しているかをチェック

check.SRfitという関数を使って、適切な推定値が得られているかを診断できます。
①収束しているか (convergence)
②ヘッセ行列 (Hessian) の対角成分が正定値 (positive definite) になっているか
③境界条件（HSの場合SSBの両端、それ以外の場合直線関係や極端に強い密度依存関係）に達しているか
④対数尤度が大域解 (global optimum) に 達しているか
⑤大域的最適解をもつパラメータがひとつに決まるかどうか（④で大域解が出られている場合のみ）
赤字でメッセージが表示された場合、問題がある可能性があります。この例のように、HSでL1を使う場合、大域解にたどり着いていなかったり、尤度が全く同じ解が複数得られることがあります。
output = TRUEで結果を出力できます。

```{r,warning=FALSE}
# SR=HS、method=L2、AR0の場合
check_L2 = check.SRfit(resL2, output = TRUE, filename = "check_L2")

# SR=HS、method=L2、AR1の場合
check_L2ARouter = check.SRfit(resL2outer, output = TRUE, filename = "check_L2ARouter")

# SR=HS、method=L1、AR0の場合
check_L1 = check.SRfit(resL1, output = TRUE, filename = "check_L1")

```
## 4. 正規性のチェック

再生産関係から予測される加入量と観測値（資源評価値）の残差が正規分布に従っているかをチェックします。check.SRdistという関数を使って、残差の分布が仮定にあっているかをチェックできます。
Shapiro-Wilk検定とKolmogorov-Smirnov 検定を行い、「残差が正規分布に従っている」という帰無仮説を検定します。
図が3つ出力され、左が標準化された（標準偏差で割られた）残差のヒストグラムで赤い線が標準正規分布を表します。右上のSWはShapiro-Wilk検定により、残差が正規分布に従っているかを検定したときのP値です。右上のKSはKolmogorov-Smirnov検定により、残差が正規分布に従っているかを検定したときのP値です。真ん中は残差の累積確率密度のヒストグラムを示しており、理論的には0~1の一様分布に従うので、このヒストグラムが大きく凸凹しているようだと仮定した確率分布と合致していないことになります。
右も累積確率密度を0~1の一様分布と仮定したときのQQプロットで、線は理論値を表しており、この線から外れていないほうがよいということになります。注意すべき点は、このQQプロットは一様分布を仮定しているので、端は線の載りやすく、中心付近が外れやすいことです。つまり、qqnorm等で出力される正規分布を仮定したQQプロットとは単純な比較はできません。これも、L1と比較するためにこういう処理をしています。
また、output=TRUEとすれば、pngファイルが出力され、保存されます。

```{r,warning=FALSE}
check.SRdist(resL2)

# 図を保存する場合。
check.SRdist(resL2, output = TRUE, filename = "ResidDistCheck_L2")
```
L1を使う場合も同様の図が描かれますが、左の図に青い点線がプロットされます。これはラプラス分布を表しており、L1の場合の尤度はラプラス分布を使って計算されるため示してあります。右上のKS (Kolmogorov-Smirnov検定) のP値もラプラス分布との一致性を検定しています。SWの方は正規分布にのみ適用できる検定なので、正規分布との一致性を検定しています。L1推定の場合は正規分布を仮定しているわけではないので、この値は参考程度としてください。
真ん中と右の図は、ラプラス分布を仮定したときの累積確率密度のヒストグラムとQQプロットになります。

```{r,warning=FALSE}
check.SRdist(resL1)
```

自己相関を外側推定した場合にはファイルが2つ出力され、1つ目が再生産関係の推定、2つ目が自己相関の推定における残差です。しがたって、1枚目の出力は上と同じになります。自己相関の推定はmethodがL1/L2によらず正規分布を仮定しています。

```{r,warning=FALSE}
check.SRdist(resL2outer)
```

自己相関を内側で推定した場合には再生産関係と自己相関係数を同時に推定するので、自己相関を除いた残差に対する図が出力されます

```{r,warning=FALSE}
check.SRdist(resL2inner)
```

## 5. 残差のトレンドと自己相関係数

残差の時間的なトレンドをチェックします。
トレンドが見られたり、自己相関係数が有意である場合には、残差の自己相関を考慮した再生産関係を検討することが望ましいです。
残差の自己相関を事後的に推定するための関数calc.residARがあります。fit.SRのout.ARオプションとやっていることは同じですが、AICの差だけではなく尤度の値やAICc等の値も取り出せます。
後述しますが、fit.SRregimeでも外側で自己相関を推定できます。
L1外側推定を例とします。
output=TRUEで結果をテキストファイルに出力します。
※このチェックは必須ではないです

```{r,warning=FALSE}
outer1 = calc.residAR(resL1outer, output = TRUE, filename = "residARouter")
rbind(outer1$pars, resL1outer$pars)
```

```{r,warning=FALSE}
c(diff(outer1$AIC), diff(resL1outer$AIC.ar))
outer1$AICc
```
autocor.plotは残差の自己相関に関するプロットを3つ出力します。左は再生産関係との残差の時系列を表しており、赤い線は平滑化された曲線です。この線が0から外れていると残差がホワイトノイズではなく、トレンドがあると言えます。
真ん中はラグを1,2,3,…年と増やした場合の自己相関係数を表しています。青い線は95％信頼区間を示しています。1年のラグで有意なときは自己相関の推定を検討したほうがよいと考えられます。
右側はLjung-Box検定におけるP値です。Ljung-Box検定の帰無仮説は「ラグが1~mまでの全ての自己相関が0である」であり、対立仮説は「ラグ1から mまでの自己相関のうち、少なくとも一つが0でない」となります (参考: https://to-kei.net/time-series-analysis/hypothesis-testing/ )。赤点で表示される箇所が有意となります。

```{r,warning=FALSE}
autocor.plot(resL1outer)
```
上は再生産関係との残差についてチェックをしましたが、自己相関を推定した後での残差についても、use.resid=2とすれば同様の図を描くことができます (デフォルトはuse.resid=1)。

```{r,warning=FALSE}
autocor.plot(resL1outer, use.resid = 2)
```

output=TRUEとすればpngファイルが出力されます。

```{r,warning=FALSE}
# 図の出力する場合。
autocor.plot(resL1outer, output = TRUE, filename = "devianceAR")
autocor.plot(resL1outer, use.resid = 2, output = TRUE, filename = "residAR")
```
診断結果：残差に時間的なトレンドは見られるが、各Lagに対するAFCやLjung-Box検定の結果から、自己相関係数は有意でなかった。

## 6. ブートストラップ

パラメータ推定の信頼性をチェックするために、残差ブートストラップを行います。信頼区間が広い場合や、ブートストラップの中央値と点推定値の乖離が大きい場合には、パラメータ推定の信頼性が低いことになります。
このチェックのためのboot.SR関数は3種類のブートストラップ方法を実装しており、うち2つが残差のブートストラップで、残り一つがデータのブートストラップです。残差ブートストラップには、パラメトリックとノンパラメトリックの2つあります。
残差のパラメトリックブートストラップは、fit.SRのpars$sdを標準偏差とする正規分布からランダムに乱数を発生させ、予測値からのずれを加えて加入量のブートストラップデータを生成し、再推定しています。
残差のパラメトリックブートストラップはmethod="p"で実行可能で、図のプロットにはbootSR.plotを使用する。
ここで25回でやっていますが、最終的に使用する予定の再生産関係には数を増やしたほうがよいと思われます（500回とか1000回）。
自己相関を推定していない場合は最後のrhoの図は表示されません。

```{r,warning=FALSE}
boot.res1 = boot.SR(resL1outer, n = 25, method = "p")
bootSR.plot(boot.res1)
```

残差のノンパラメトリックブートストラップは残差の確率分布を仮定せず、残差を重複ありでリサンプリングして、加入量のブートストラップデータを生成します。
確率分布を仮定しないので、L1とL2を比較する場合にはパラメトリックよりもこちらの方がよいかもしれません。
ノンパラメトリックブートストラップはmethod="n"で行います。

```{r,warning=FALSE}
boot.res2 = boot.SR(resL1outer, n = 25, method = "n")
bootSR.plot(boot.res2)
```

データのブートストラップはデータを重複ありでリサンプリングしたデータを使用して、再生産関係の再推定を行います。
親魚量データもリサンプリングにより変化するため、親魚量の不確実性も考慮されることになります。
親魚量データに偏りがあったり、データ数が少なかったり、あるデータ点に推定値が大きく依存している場合はバイアスや不確実性が大きくなりやすいと思われます。
データブートストラップはmethod="d"で行います。
自己相関を内部推定している場合には、厳密にはこの手法でいいのか、改善できるかすべきかは検討中です。
残差ブートストラップを基本として、データのブートストラップはオプションで参考程度でよいと思います。

```{r,warning=FALSE}
boot.res3 = boot.SR(resL1outer, n = 25, method = "d")
bootSR.plot(boot.res3)
```

図を画像ファイルとして保存する場合はoutput=TRUEとします。

```{r,warning=FALSE}
# 図を保存する場合。
bootSR.plot(boot.res1, filename = "para_boot", output = TRUE)
bootSR.plot(boot.res2, filename = "nonpara_boot", output = TRUE)
bootSR.plot(boot.res3, filename = "data_boot", output = TRUE)
```

診断結果：パラメータaとbは、ブートストラップ推定値の中央値と点推定値がおよそ一致した。ノンパラメトリックブートストラップではsigmaはややずれていた。
再生産関係は比較的ロバストであった。

## 7. ジャックナイフ推定

パラメータ推定の頑健性を調べるために、一点ずつ除いてデータをジャックナイフ解析を行います。これにより、どの年のデータの影響が大きいかが明らかになります。

```{r,warning=FALSE}
jack1 = jackknife.SR(resL1outer, is.plot = TRUE)
```

output = TRUEで図を画像ファイルとして保存できます。

```{r,warning=FALSE}
# 図を保存する場合。
jack1 = jackknife.SR(resL1outer, output = TRUE, is.plot = TRUE)
```

診断結果：1998年・2006年のデータを除くとbの推定値がやや大きくなる。
そのほかのパラメータは各データの除去に対して比較的頑健である。


## 8. プロファイル尤度

再生産関係のパラメータa,bを変化させたときの尤度を計算し、点推定値以外に、尤度が高くなっている山が無いかをチェックします。
自己相関を内部推定している場合はa,bを固定して尤度が最も高くなる自己相関係数rhoを推定しています。
HSで自己相関を内部推定すると複数の山が現れることが知られていますので、HSや自己相関の内部推定を検討する場合は重要な診断となります。
この結果とブートストラップ信頼区間およびジャックナイフ解析の結果も同時に図示します。


```{r,warning=FALSE}
prof1 = prof.likSR(resL1outer)
```
output = TRUEで図を画像ファイルとして保存できます。

```{r,warning=FALSE}
# 図を保存する場合。
prof2 = prof.likSR(resL2inner, output = TRUE)
```

診断結果：パラメータの値を変化させても尤度の変化は比較的小さい。

## 9. パラメータ間相関
パラメータa, bの値がどれだけ相関を持つか、相関係数を算出します。パラメータa, b間の相関が強いと推定が不安定になっている可能性があります。

```{r,warning=FALSE}
res_corSR <- corSR(resSR=resL1)
res_corSR$cor[1,2]
```

診断結果：相関係数の値は小さく、パラメータa,bは関連は小さい。

## 10. スティープネス
SR=BH,RIにおいて、F=0の時の初期資源量から理論上求められる加入量R0に対する、0.2B0の時の加入量Rの比であるスティープネスhが計算されます。すなわち、
SR=BHでは
h = (a 0.2B0 / (1 + b 0.2B0) ) / R0 = a 0.2SPR0/( (1 + b 0.2B0))
となり、
SR=RIでは
h = a 0.2B0 exp (-b 0.2B0) / R0 = a 0.2SPR0 exp (-b 0.2B0)
となります。
スティープネスは再生産モデルの密度補償効果の程度を示します。0.2から1の間の値を取り、0.2の時は密度補償効果がないことを、1の時は親魚量に関わらず一定の加入量が得られることを意味します。
また、SR=HSのときはPunt et al. (2013)[https://doi.org/10.1093/icesjms/fst162]に従い、
h= 1 - b/B0
と定義します。

```{r,warning=FALSE}
year <- as.character(max(res_vpa$input$rec.year))
res_steepness <- calc_steepness(SR=resL2$input$SR,rec_pars=resL2$pars,M=res_vpa$input$dat$M[,year],waa=res_vpa$input$dat$waa[,year],maa=res_vpa$input$dat$maa[,year])
res_steepness$h
```

診断結果：スティープネスの値から十分な密度補償効果があると考えられる。
<!-- ## 7. まとめ -->

# 再生産関係のレジームがあると考えられる場合。

## 1. 再生産関係の推定
推定にはfit.SRregimeを使います。ここではHS, L1で、2005年にレジームシフトが生じた場合を候補とします。
仮に1995年と2005年に2回レジームシフトが起こったとして、レジームがA->B->Aと変化する場合はregime.key = c(0,1,0)、A->B->Cと変化する場合はregime.key = 0:2と指定します。
regime.year = c(1995,2005)と指定してください。
regime.parはレジームごとに異なるパラメータを設定します。今はすべてのパラメータが異なる場合 (resR1) とaは共通でbとsdが異なる場合 (resR2) を使います。
AICc等の結果はfit.SRと比較できます。
詳しくは?fit.SRregimeを参照ください。
図の保存などはvignette"fittingSR.rmd"「fitSR関数を再生産関係の推定」を参照ください。

```{r,warning=FALSE}
resR1 <- fit.SRregime(SRdata, SR = "HS", method = "L1", regime.year = c(2005), regime.par = c("a", 
    "b", "sd")[1:3], use.fit.SR = TRUE, regime.key = c(0, 1))
resR2 <- fit.SRregime(SRdata, SR = "HS", method = "L1", regime.year = c(2005), regime.par = c("a", 
    "b", "sd")[2:3], use.fit.SR = TRUE, regime.key = c(0, 1))
c(resL2$AICc, resL1$AICc, resL2inner$AICc, resR1$AICc, resR2$AICc)
```

## 2.推定値の収束の有無や最適解に達しているかをチェック

fit.SRregimeの場合でもcheck.SRfitという関数を使って、適切な推定値が得られているかを診断できます。
resR1では、「異なるパラメータ値で同じ最大対数尤度が得られる」という結果になっています。

```{r,warning=FALSE}
check_R1 = check.SRfit(resR1, output = TRUE, filename = "check_R1")
check_R2 = check.SRfit(resR2, output = TRUE, filename = "check_R2")
```
resR2では「最適解に達していない」というメッセージが出ます。
このメッセージが出た場合、optimumに最適解の結果オブジェクトが格納されていますので、対数尤度やAICcやパラメータ値を比較できます。

```{r,warning=FALSE}
# 対数尤度の比較
c(resR2$loglik, check_R2$optimum$loglik)
```
```{r,warning=FALSE}
# AICcの比較
c(resR2$AICc, check_R2$optimum$AICc)
```
```{r,warning=FALSE}
# 推定されたと最適化されたパラメータの表示
resR2$regime_pars
check_R2$optimum$regime_pars
```

最適解を更新して再チェックできます。
結果を更新すれば問題ないという結果になるはず…
HS & L1でも解が一意的に求まる場合と求まらない場合の差は分からないが、レジームを完全に分けるなどパラメータ数に対してデータが少ない場合に生じやすいように思われる。

```{r,warning=FALSE}
resR2 = check_R2$optimum
check_R2 = check.SRfit(resR2, output = TRUE, filename = "check_R2")
```

## 3.残差の分布のチェック

残差の確率分布のプロットはfit.SRと同様に出力できます。

```{r,warning=FALSE}
check.SRdist(resR1)
```

## 4.残差の自己相関のチェック

レジームを推定してから自己相関を事後的に推定することができます。
calc.residARを使い、per_regime = TRUEでレジームごとに自己相関を推定、per_regime = FALSEでレジーム間で共通の自己相関係数を推定できます。
ここで自己相関係数が大きかったりAICcが大きく下がったからと言って将来予測および管理基準値計算に自己相関を考慮すべきかはわかりません。個人的には、自己相関はレジームの代替手段として考慮するものですし、自己相関とレジームを両方考慮した再生産関係を見たことがないので、自己相関は考慮しないでいいのではないかと思います。

```{r,warning=FALSE}
outer_R1 = calc.residAR(resR1, per_regime = TRUE)
```

```{r,warning=FALSE}
outer_R1$regime_pars
```

```{r,warning=FALSE}
outer_R1$AICc
```


```{r,warning=FALSE}
outer_R0 = calc.residAR(resR1, per_regime = FALSE)
```
```{r,warning=FALSE}
outer_R0$regime_pars
```

```{r,warning=FALSE}
outer_R0$AICc
```

もしどうしてもレジームありで自己相関を内部推定したい場合には、fit.SRの引数のwを使用することで、レジームを完全に分けての推定はできます。

```{r,warning=FALSE}
w = as.numeric(!(SRdata$year %in% 1976:1987))
resR3 <- fit.SR(SRdata, SR = "HS", method = "L2", AR = 1, out.AR = FALSE, w = w)
resR3$pars
```

自己相関に関するプロットはautocor.plotで出力されますが、標準偏差が年代によって変わっているので標準化残差を使っています。

```{r,warning=FALSE}
autocor.plot(resR1)
```

## 4.ブートストラップ

fit.SRregimeでもboot.SRを使ってfit.SRと同様に、①残差のパラメトリックブートストラップ、②残差のノンパラメトリックブートストラップ、③データのブートストラップを行うことができます。
残差の標準偏差がレジームによって変わるので、標準化残差に直したうえで残差ブートストラップをやり、元の標準偏差の大きさに戻しています。
ここでは例として残差のノンパラメトリックブートストラップを示します。レジーム毎に各パラメータのヒストグラムが表示されます。

```{r,warning=FALSE}
boot.res4 = boot.SR(resR1, n = 25, method = "n")
bootSR.plot(boot.res4)
```

レジーム間で共通のパラメータは各レジームで同じ図となります。

```{r,warning=FALSE}
boot.res5 = boot.SR(resR2, n = 25, method = "n")
bootSR.plot(boot.res5)
```

## 5.ジャックナイフ

ジャックナイフも同様にレジームごとに結果が表示されます。
レジームシフトの位置を青点線で示しています。
レジーム間で共通のパラメータがある場合はレジーム間で同じ図が表示されます。

```{r,warning=FALSE}
jack2 = jackknife.SR(resR1, is.plot = TRUE)
```

```{r,warning=FALSE}
jack3 = jackknife.SR(resR2, is.plot = TRUE)
```


## 6.プロファイル尤度

プロファイル尤度もfit.SRのときと同様の関数prof.likSRで計算・プロットできます。
レジームごとにa,bのパラメータを動かし、別のレジームで推定が必要なパラメータは尤度が最大になるように推定しています（そのため計算に時間がかかります）。
図はレジームごとに出力されます。

```{r,warning=FALSE}
prof2 = prof.likSR(resR1)
```

## 7.パラメータ間相関

レジームがある場合でもパラメータ間の相関係数が計算できます。
パラメータはa,bのセットが２つ生成されますので、それぞれのセットの相関係数が出力されます。

```{r,warning=FALSE}
res_corSR_R1 <- corSR(resSR=resR1)
# 一つ目
res_corSR_R1$cor[1,3]
# 二つ目
res_corSR_R1$cor[2,4]
```

## 8.スティープネス

レジームがある場合、レジームごとに計算します。
パラメータセットをレジームごとに用意し、calc_steepness関数の引数に入れます。

```{r,warning=FALSE}
year <- as.character(max(res_vpa$input$rec.year))
# 一つ目のレジーム
reg1_pars <-as.data.frame(cbind(resR1$pars$a[1],resR1$pars$b[1]))
names(reg1_pars) <- c("a","b")
res_steepness_reg1 <- calc_steepness(SR=resR1$input$SR,rec_pars=reg1_pars,M=res_vpa$input$dat$M[,year],waa=res_vpa$input$dat$waa[,year],maa=res_vpa$input$dat$maa[,year])
res_steepness_reg1$h
```

```{r,warning=FALSE}
# 二つ目のレジーム
reg2_pars <-as.data.frame(cbind(resR1$pars$a[2],resR1$pars$b[2]))
names(reg2_pars) <- c("a","b")
res_steepness_reg2 <- calc_steepness(SR=resR1$input$SR,rec_pars=reg2_pars,M=res_vpa$input$dat$M[,year],waa=res_vpa$input$dat$waa[,year],maa=res_vpa$input$dat$maa[,year])
res_steepness_reg2$h
```

# 複数の再生産関係についてまとめてモデル診断

複数の再生産関係の候補モデルについてまとめてモデル診断を行うための例コードを示します。
再生産関係モデルごとにフォルダを生成してそこに結果を出力します。

```{r,warning=FALSE}
# 再生産関係の候補を決め、名前を決めます
# この名前のフォルダが生成され結果が格納される
SRname_list = c("HSL2outer", "HSL2inner", "HSL2regime", "HSL1regime")
for (i in 1:length(SRname_list)) {
    SRname = SRname_list[i]
    dir.create(SRname)
    # 各モデルの設定をここで変えます (SRname_listの1番目から順番に)
    resSR = switch(i, fit.SR(SRdata, SR = "HS", AR = 1, out.AR = TRUE, length = 50), 
                      fit.SR(SRdata, SR = "HS", AR = 1, out.AR = FALSE, length = 50), 
                      fit.SRregime(SRdata, SR = "HS", method = "L2", regime.year = c(2005), 
                          regime.par = c("a", "b", "sd")[1:3], regime.key = c(0, 1), length = 10, use.fit.SR = FALSE), 
                      fit.SRregime(SRdata, SR = "HS", method = "L1", regime.year = c(2005), 
                          regime.par = c("a","b", "sd")[1:3], regime.key = c(0, 1), length = 10, use.fit.SR = FALSE))
    # 収束＆大域解かどうかを診断
    check = check.SRfit(resSR, output = TRUE, filename = paste0(SRname, "/checkSRfit_", 
        SRname))
    if (!is.null(check$optimum)) {
        # 大域解に達していない場合、結果を更新して再チェック
        resSR = check$optimum
        check = check.SRfit(resSR, output = TRUE, filename = paste0(SRname, "/checkSRfit_", 
            SRname))
    }
    # 結果をtxtファイルに出力
    out.SR(resSR, filename = paste0(SRname, "/resSR_", SRname))
    # 再生産関係の図を出力
    if (class(resSR) == "fit.SR") {
        g1 = SRplot_gg(resSR)
        ggsave_SH(g1, file = paste0(SRname, "/SRcurve_", SRname, ".png"))
    } else {
        g1 = SRregime_plot(resSR, labeling.year = c(min(SRdata$year), SRdata$year[SRdata$year %in% 
            seq(1900, 2100, by = 10)], max(SRdata$year)))
        ggplot2::ggsave(g1, file = paste0(SRname, "/SRcurve_", SRname, ".png"), unit = "mm", 
            width = 240, height = 120, dpi = 600)
    }
    # プロファイル尤度を計算
    proflik = prof.likSR(resSR, output = TRUE, filename = paste0(SRname, "/ProfLik_", 
        SRname))
    # 残差の分布チェック
    check.SRdist(resSR, output = TRUE, filename = paste0(SRname, "/ResidDist_", SRname))
    # 残差の自己相関をチェック
    autocor.plot(resSR, output = TRUE, filename = paste0(SRname, "/devianceSR_", 
        SRname))
    # 自己相関を推定した場合、自己相関の推定後の残差に対してもチェックを行う
    if (class(resSR) == "fit.SR" && resSR$input$AR) {
        autocor.plot(resSR, use.resid = 2, output = TRUE, filename = paste0(SRname, 
            "/residualSR_", SRname))
    }
    # ジャックナイフ解析
    jack1 = jackknife.SR(resSR, output = TRUE, is.plot = TRUE, filename = paste0(SRname, 
        "/jackknife_", SRname))
    
    # ブートストラップ解析 ブートストラップの回数 ※ここでは10回
    nboot = 10
    # パラメトリック
    boot.res1 = boot.SR(resSR, n = nboot, method = "p")
    bootSR.plot(boot.res1, filename = paste0(SRname, "/para_boot_", SRname), output = TRUE)
    # ノンパラメトリック
    boot.res2 = boot.SR(resSR, n = nboot, method = "n")
    bootSR.plot(boot.res2, filename = paste0(SRname, "/nonpara_boot_", SRname), output = TRUE)
    # 結果の保存
    SRdiagnosis = list(resSR = resSR, ProfLik = proflik, ParaBoot = boot.res1, NonParaBoot = boot.res2, 
        Jackknife = jack1)
    save(SRdiagnosis, file = paste0(SRname, "/SRdiagnosis.rda"))
}
```
